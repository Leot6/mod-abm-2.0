/// \author Jian Wen
/// \date 2021/01/29

#pragma once

#include <yaml-cpp/yaml.h>

#include <osrm/json_container.hpp>
#include <string>

//////////////////////////////////////////////////////////////////////////////////////////////////
/// Geo Types
//////////////////////////////////////////////////////////////////////////////////////////////////

/// \brief Position encoded in longitude/latitude.
/// \details lon in [-180, 180), lat in [-90, 90]. Undefined behaviors if out of bound.
struct Pos {
    float lon = 0.0;
    float lat = 0.0;
};

/// \brief Step of route consisting of distance, duration and a vector of continuous positions.
struct Step {
    int32_t distance_mm = 0;
    int32_t duration_ms = 0;
    std::vector<Pos> poses;
};

/// \brief Leg of route consisting of total distance, total duration as well as a vector of steps.
struct Leg {
    int32_t distance_mm = 0;
    int32_t duration_ms = 0;
    std::vector<Step> steps;
};

/// \brief Route consisting of total distance, total duration as well as a vector of legs.
struct Route {
    int32_t distance_mm = 0;
    int32_t duration_ms = 0;
    std::vector<Leg> legs;
};

/// \brief The type of the routing call.
enum class RoutingType {
    UNDEFINED, // uninitialized value
    TIME_ONLY, // only return the total travel time and distance
    FULL_ROUTE // return the full route with detailed maneuvers
};

/// \brief The status of the routing response.
enum class RoutingStatus {
    UNDEFINED, // uninitialized value
    OK,        // good route
    EMPTY,     // empty route
    ERROR      // error
};

/// \brief The response from the routing engine.
struct RoutingResponse {
    RoutingStatus status = RoutingStatus::UNDEFINED;
    std::string message = "";
    Route route;
};

//////////////////////////////////////////////////////////////////////////////////////////////////
/// Trip Types
//////////////////////////////////////////////////////////////////////////////////////////////////

/// \brief A single demand OD with accumulated probability.
/// \details The accumulated probability of a OD is a double between (0, 1]. We use these to form
/// a list of ODs with increasing probs to be able to generate a random request based on each OD's
/// trip intensity. For example, the first OD has a probability of 0.1 among all trips and the
/// accumulated prob will be 0.1. The second OD has a probability of 0.1 and the accumulated prob
/// will be 0.2 (0.1 + 0.1). The third OD has a probability of 0.05 and the accumulated prob in
/// this case will be 0.25 (0.2 + 0.05). To generate a trip, we generate a random number between
/// 0 and 1. If the random number falls into [0.1, 0.2), the origin/destination of the generated
/// trip will be based on the second OD.
struct OdWithProb {
    Pos origin;
    Pos destination;
    double accumulated_prob;
};

/// \brief The trip request generated by the demand generator.
struct Request {
    Pos origin;
    Pos destination;
    uint64_t request_time_ms = 0;
};

/// \brief The status of the trip.
enum class TripStatus {
    UNDEFINED,   // uninitialized value
    REQUESTED,   // the trip has been generated by the demand generator
    DISPATCHED,  // the vehicle has been dispatched to serve the trip
    PICKED_UP,   // the trip has been picked up
    DROPPED_OFF, // the trip has been dropped off, trip completed
    WALKAWAY     // the trip isn't served due to constraints in dispatch time/pickup time etc
};

inline std::string to_string(const TripStatus &s) {
    if (s == TripStatus::UNDEFINED) {
        return "UNDEFINED";
    } else if (s == TripStatus::REQUESTED) {
        return "REQUESTED";
    } else if (s == TripStatus::DISPATCHED) {
        return "DISPATCHED";
    } else if (s == TripStatus::PICKED_UP) {
        return "PICKED_UP";
    } else if (s == TripStatus::DROPPED_OFF) {
        return "DROPPED_OFF";
    } else if (s == TripStatus::WALKAWAY) {
        return "WALKAWAY";
    }

    assert(false && "Bad TripStatus type!");
}

/// \brief The trip that the simulation managed, containing all relavant data.
struct Trip {
    size_t id;
    Pos origin;
    Pos destination;
    TripStatus status = TripStatus::UNDEFINED;
    int32_t request_time_ms = 0;
    int32_t max_pickup_time_ms = 0;
    int32_t pickup_time_ms = 0;
    int32_t dropoff_time_ms = 0;
};

//////////////////////////////////////////////////////////////////////////////////////////////////
/// Vehicle Types
//////////////////////////////////////////////////////////////////////////////////////////////////

/// \brief The operation associated with a waypoint.
enum class WaypointOp {
    UNDEFINED, // uninitialized value
    PICKUP,    // we pick up a trip at this waypoint
    DROPOFF,   // we drop off a trip at this waypoint
};

/// \brief The waypoint represents a stop along the way when the vehicle serves trips.
struct Waypoint {
    Pos pos;
    WaypointOp op;
    size_t trip_id;
    Route route;
};

/// \brief The vehicle type that holds dispatched trips and waypoints.
struct Vehicle {
    size_t id;
    Pos pos;
    size_t capacity = 1;
    size_t load = 0;
    std::vector<Waypoint> waypoints = {};
    int32_t dist_traveled_mm = 0; // accumulated distance traveled in meters
    int32_t loaded_dist_traveled_mm =
        0; // accumulated distance traveled, weighted by the load, in meters
};
